<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <title>Polaris Touch</title>
  <script type="module" crossorigin>(function polyfill() {
  const relList = document.createElement("link").relList;
  if (relList && relList.supports && relList.supports("modulepreload")) return;
  for (const link of document.querySelectorAll('link[rel="modulepreload"]')) processPreload(link);
  new MutationObserver((mutations) => {
    for (const mutation of mutations) {
      if (mutation.type !== "childList") continue;
      for (const node of mutation.addedNodes) if (node.tagName === "LINK" && node.rel === "modulepreload") processPreload(node);
    }
  }).observe(document, {
    childList: true,
    subtree: true
  });
  function getFetchOpts(link) {
    const fetchOpts = {};
    if (link.integrity) fetchOpts.integrity = link.integrity;
    if (link.referrerPolicy) fetchOpts.referrerPolicy = link.referrerPolicy;
    if (link.crossOrigin === "use-credentials") fetchOpts.credentials = "include";
    else if (link.crossOrigin === "anonymous") fetchOpts.credentials = "omit";
    else fetchOpts.credentials = "same-origin";
    return fetchOpts;
  }
  function processPreload(link) {
    if (link.ep) return;
    link.ep = true;
    const fetchOpts = getFetchOpts(link);
    fetch(link.href, fetchOpts);
  }
})();
class TouchManager {
  onTouchEnd = void 0;
  onTouchChange = void 0;
  onTouchStart = void 0;
  touchStartTimes = /* @__PURE__ */ new Map();
  constructor() {
    document.addEventListener("touchmove", (e) => {
      if (this.onTouchChange) {
        this.onTouchChange(e.changedTouches);
      }
      e.preventDefault();
    });
    document.addEventListener("touchstart", (e) => {
      for (const touch of e.changedTouches) {
        this.touchStartTimes.set(touch.identifier, Date.now());
      }
      if (this.onTouchStart) {
        this.onTouchStart(e.changedTouches);
      }
      if (this.onTouchChange) {
        this.onTouchChange(e.changedTouches);
      }
      e.preventDefault();
    });
    document.addEventListener("touchend", (e) => {
      this.touchEnd(e.changedTouches);
      e.preventDefault();
    });
    document.addEventListener("touchcancel", (e) => {
      this.touchEnd(e.changedTouches);
      e.preventDefault();
    });
    document.addEventListener("mousedown", (e) => {
      const fakeTouch = {
        clientX: e.clientX,
        clientY: e.clientY,
        identifier: "MOUSE"
      };
      this.touchStartTimes.set(fakeTouch.identifier, Date.now());
      if (this.onTouchStart) {
        this.onTouchStart([fakeTouch]);
      }
      if (this.onTouchChange) {
        this.onTouchChange([fakeTouch]);
      }
    });
    document.addEventListener("mousemove", (e) => {
      if (!this.touchStartTimes.has("MOUSE")) {
        return;
      }
      const fakeTouch = {
        clientX: e.clientX,
        clientY: e.clientY,
        identifier: "MOUSE"
      };
      if (this.onTouchChange) {
        this.onTouchChange([fakeTouch]);
      }
    });
    document.addEventListener("mouseup", (e) => {
      const fakeTouch = {
        clientX: e.clientX,
        clientY: e.clientY,
        identifier: "MOUSE"
      };
      this.touchEnd([fakeTouch]);
    });
  }
  touchEnd(changedTouches) {
    if (this.onTouchChange) {
      this.onTouchChange(changedTouches, true);
    }
    const instaRelease = [];
    for (const touch of changedTouches) {
      const startTime = this.touchStartTimes.get(touch.identifier);
      if (startTime == void 0) {
        throw new Error("?");
      }
      const duration = Date.now() - startTime;
      this.touchStartTimes.delete(touch.identifier);
      if (duration > 8) {
        instaRelease.push(touch);
        continue;
      }
      setTimeout(() => {
        if (this.onTouchEnd) {
          this.onTouchEnd([touch]);
        }
      }, 8 - duration);
    }
    if (this.onTouchEnd && instaRelease.length) {
      this.onTouchEnd(instaRelease);
    }
  }
}
class SpiceConnection {
  constructor(_host) {
    this._host = _host;
    this._socket = new WebSocket(_host);
    this.setServer(_host);
    this._socket.onopen = () => {
      this.setStatus("CONNECTED");
    };
    this._socket.onerror = () => {
      this.setStatus("ERROR");
      this.disconnect();
    };
    this._socket.onclose = () => {
      this.setStatus("CLOSED");
      this.setServer("<NONE>");
      this._socket = null;
    };
  }
  _socket;
  _statusElement = document.querySelector("#connection");
  _serverElement = document.querySelector("#server");
  _id = 0;
  setServer(server) {
    if (this._serverElement) {
      this._serverElement.innerText = server;
    }
  }
  setStatus(status) {
    if (this._statusElement) {
      this._statusElement.innerText = status;
    }
  }
  send(command) {
    if (!this._socket) {
      return;
    }
    const packet = new TextEncoder().encode(JSON.stringify(command) + "\0");
    this._socket.send(packet);
  }
  disconnect() {
    this._socket?.close();
  }
  get valid() {
    return !!this._socket;
  }
  get connected() {
    return this._socket?.readyState == WebSocket.OPEN;
  }
  get host() {
    return this._host;
  }
  get id() {
    return this._id++;
  }
}
function listenHold(element, callback, duration = 2e3) {
  let down = false;
  element.addEventListener("touchstart", () => {
    if (down) {
      return;
    }
    down = true;
    const timer = setTimeout(() => {
      callback();
    }, duration);
    element.addEventListener("touchend", () => {
      down = false;
      clearTimeout(timer);
    });
    element.addEventListener("touchcancel", () => {
      down = false;
      clearTimeout(timer);
    });
  });
  element.addEventListener("mousedown", () => {
    if (down) {
      return;
    }
    down = true;
    const timer = setTimeout(() => {
      callback();
    }, duration);
    element.addEventListener("mouseup", () => {
      down = false;
      clearTimeout(timer);
    });
  });
}
const FADER_DEAD_ZONE = 10;
function getSpiceHost(reset = false, text = null) {
  let spiceHost = reset ? null : window.localStorage.getItem("api_backend");
  if (spiceHost) {
    return spiceHost;
  }
  const ipPort = prompt(text ?? `Enter SpiceAPI Endpoint (IP:PORT)

READ THIS:
Please disable password as I don't want to write the RC4 code.

Touch the "ws://....." on status bar for more than 2s then release for re-set SpiceAPI endpoint.

Thanks for your using, by GEEKi`, "192.168.1.100:1337");
  if (!ipPort) {
    return getSpiceHost(true, "Please enter SpiceAPI Endpoint");
  }
  if (!/\d+\.\d+\.\d+\.\d+\:\d+/.test(ipPort)) {
    return getSpiceHost(true, "Please enter a correct SpiceAPI Endpoint\n(example: 192.168.1.100:1337):");
  }
  const [ip, port] = ipPort.split(":");
  spiceHost = `ws://${ip}:${parseInt(port) + 1}/`;
  window.localStorage.setItem("api_backend", spiceHost);
  return spiceHost;
}
if (window.location.protocol.toLowerCase() == "https:") {
  alert("Please use HTTP instead, You can't connect to insecure websocket in https environment.");
  throw new Error("NO_HTTPS");
}
let lastLaneState = new Array(12).fill(false);
function sendButtonState(laneState2) {
  if (!window.ctx?.valid || !window.ctx.connected) {
    return;
  }
  const buttonDelta = [];
  for (let i = 0; i < laneState2.length; i++) {
    const cur = laneState2[i];
    const last = lastLaneState[i];
    if (cur != last) {
      buttonDelta.push([`Button ${i + 1}`, cur ? 1 : 0]);
    }
  }
  if (buttonDelta.length) {
    window.ctx.send({
      id: window.ctx.id,
      module: "buttons",
      function: "write",
      params: buttonDelta
    });
    lastLaneState = laneState2.slice();
  }
}
let lastFaderAnalog = [0, 0];
function sendAnalogState(faderAnalog) {
  if (!window.ctx?.valid || !window.ctx.connected) {
    return;
  }
  const analogDelta = [];
  for (let i = 0; i < faderAnalog.length; i++) {
    const cur = faderAnalog[i];
    const last = lastFaderAnalog[i];
    if (cur != last) {
      analogDelta.push([`Fader-${["L", "R"][i]}`, cur]);
    }
  }
  if (analogDelta.length) {
    window.ctx.send({
      id: window.ctx.id,
      module: "analogs",
      function: "write",
      params: analogDelta
    });
    lastFaderAnalog = faderAnalog.slice();
  }
}
window.touchMgr = new TouchManager();
window.ctx = new SpiceConnection(getSpiceHost());
setInterval(() => {
  if (!window.ctx || !window.ctx.valid) {
    window.ctx = new SpiceConnection(getSpiceHost());
  }
}, 1e3);
const statusServer = document.querySelector("#server");
if (statusServer) {
  listenHold(statusServer, () => {
    window.ctx?.disconnect();
    window.ctx = new SpiceConnection(getSpiceHost(true));
  });
}
const lanes = Array.from(document.querySelectorAll(".lane>div"));
const faderPositions = Array.from(document.querySelectorAll(".fader .position"));
const laneState = new Array(12).fill(false);
const faderTouches = [null, null];
const lastFaderPositions = [null, null];
const faderDirs = [0, 0];
const faderAnalogs = [0.51, 0.51];
let frames = 0;
let lastUpdate = Date.now();
const statusFps = document.querySelector("#fps");
const statusFader = document.querySelector("#fader");
function updateFaderAnalog() {
  let updated = false;
  for (let i = 0; i < 2; i++) {
    let analog = faderAnalogs[i];
    const dir = faderDirs[i];
    if (dir == 0) {
      if (analog == 0.5) {
        continue;
      }
      analog += (0.5 - analog) * 1.7999;
      if (Math.abs(0.5 - analog) < 0.01) {
        analog = 0.5;
      }
    } else {
      const dest = dir > 0 ? 1 : 0;
      if (analog == dest) {
        continue;
      }
      analog += (dest - analog) / 4;
      if (Math.abs(dest - analog) < 0.01) {
        analog = dest;
      }
    }
    faderAnalogs[i] = Math.min(1, Math.max(0, analog));
    updated = true;
  }
  if (updated) {
    sendAnalogState(faderAnalogs);
    const areaWidth = document.body.clientWidth / 2;
    for (let i = 0; i < 2; i++) {
      const faderPosition = faderPositions[i];
      const x = faderAnalogs[i] * areaWidth;
      faderPosition.style = `left: ${x}px`;
    }
  }
}
let laneTouches = new Array(12).fill([]);
function updateLaneState() {
  for (let i = 0; i < 12; i++) {
    laneState[i] = !!laneTouches[i].length;
  }
}
function removeTouches(touches) {
  let changed = false;
  for (let i = 0; i < 12; i++) {
    const oldLen = laneTouches[i].length;
    laneTouches[i] = laneTouches[i].filter((v) => touches.findIndex((t) => t.identifier == v) == -1);
    if (oldLen != laneTouches[i].length) {
      changed = true;
    }
  }
  return changed;
}
window.touchMgr.onTouchStart = (touches) => {
  const touchArr = Array.from(touches);
  for (const touch of touchArr) {
    const x = touch.clientX / document.body.clientWidth;
    const y = touch.clientY / document.body.clientHeight;
    if (y > 0.5) {
      continue;
    }
    if (faderTouches[1] && touch.clientX < faderTouches[1].clientX) {
      faderTouches[0] = touch;
    } else if (x < 0.5 && !faderTouches[0]) {
      faderTouches[0] = touch;
    }
    if (faderTouches[0] && touch.clientX > faderTouches[0].clientX) {
      faderTouches[1] = touch;
    } else if (x > 0.5 && !faderTouches[1]) {
      faderTouches[1] = touch;
    }
  }
};
window.touchMgr.onTouchChange = (touches, noSend) => {
  const touchArr = Array.from(touches);
  let changed = removeTouches(touchArr);
  for (const touch of touchArr) {
    const x = touch.clientX / document.body.clientWidth;
    const y = touch.clientY / document.body.clientHeight;
    if (touch.identifier == faderTouches[0]?.identifier) {
      faderTouches[0] = touch;
      continue;
    }
    if (touch.identifier == faderTouches[1]?.identifier) {
      faderTouches[1] = touch;
      continue;
    }
    if (y < 0.5) {
      continue;
    }
    const column = Math.max(0, Math.min(Math.floor(x * 12), 11));
    laneTouches[column].push(touch.identifier);
    changed = true;
  }
  if (changed) {
    updateLaneState();
    if (!noSend) sendButtonState(laneState);
  }
  frames++;
};
window.touchMgr.onTouchEnd = (touches) => {
  const touchArr = Array.from(touches);
  const changed = removeTouches(touchArr);
  if (changed) {
    updateLaneState();
    sendButtonState(laneState);
  }
  for (let i = 0; i < 2; i++) {
    const faderTouch = faderTouches[i];
    if (!faderTouch) {
      continue;
    }
    for (const touch of touchArr) {
      if (faderTouch.identifier !== touch.identifier) {
        continue;
      }
      faderTouches[i] = null;
      lastFaderPositions[i] = null;
      faderDirs[i] = 0;
      break;
    }
  }
  frames++;
};
const update = () => {
  for (let i = 0; i < lanes.length; i++) {
    const column = lanes[i];
    const isTouched = laneState[i];
    if (isTouched) {
      column.classList.add("active");
    } else {
      column.classList.remove("active");
    }
  }
  const areaWidth = document.body.clientWidth / 2;
  for (let i = 0; i < 2; i++) {
    const faderTouch = faderTouches[i];
    if (!faderTouch) {
      continue;
    }
    const x = faderTouch.clientX - i * areaWidth;
    const lastX = lastFaderPositions[i];
    if (lastX !== null) {
      const delta = x - lastX;
      if (Math.abs(delta) > FADER_DEAD_ZONE) {
        faderDirs[i] = Math.sign(delta);
      }
    } else {
      faderDirs[i] = 0;
    }
    lastFaderPositions[i] = x;
  }
  if (Date.now() - lastUpdate > 1e3) {
    lastUpdate = Date.now();
    if (statusFps) {
      statusFps.innerHTML = `${frames} Hz`;
    }
    frames = 0;
  }
  if (statusFader) {
    statusFader.innerHTML = faderAnalogs.map((v) => v.toFixed(2)).join(" | ");
  }
  updateFaderAnalog();
  window.requestAnimationFrame(update);
};
requestAnimationFrame(update);</script>
  <style rel="stylesheet" crossorigin>body {
  margin: 0;
  touch-action: none;
  background-color: #000;
  font-family: Arial, Helvetica, sans-serif;
}

* {
  user-select: none;
  -webkit-user-select: none;
}

.container {
  height: 100vh;
}

.fader {
  display: flex;
  height: 50vh;
}

.fader>div {
  width: 50%;
  position: relative;
  overflow: hidden;
}

.fader>div>.position {
  position: absolute;
  height: 100%;
  width: 2px;
  display: none;
  z-index: 999;
  transform: translateX(-1px);
}

.fader>div>.position.visible {
  display: block;
}

.fader #left {
  background: linear-gradient(to right, rgba(69, 233, 123, 0.8), rgba(69, 233, 123, 0.4));
}

.fader #left .position {
  background-color: rgba(0, 255, 0);
}

.fader #right {
  background: linear-gradient(to left, rgba(218, 69, 216, 0.8), rgba(218, 69, 216, 0.4));
}

.fader #right .position {
  background-color: rgba(255, 0, 255);
}

.lane {
  display: flex;
  background-color: #000;
  height: 50vh;
}

.lane>div {
  width: calc(100vw / 12);
  color: #fff;
}

.lane>div:not(:last-child) {
  border-right: 1px solid rgba(255, 255, 255, 0.2);
}

.lane>div.active {
  background-color: rgba(255, 255, 255, 0.3);
}

.status {
  background-color: #000;
  color: #ccc;
  border: 1px solid rgba(255, 255, 255, 0.2);

  font-size: 12px;
  line-height: 24px;
  display: flex;
}

.status>div {
  padding-left: 1em;
  padding-right: 1em;
  border-right: 1px solid rgba(255, 255, 255, 0.2);
}</style>
</head>

<body>
    <div class="container">
        <div class="status">
            <div id="fps">0 Hz</div>
            <div id="fader">CENTER | CENTER</div>
            <div id="connection">NOT CONNECTED</div>
            <div id="server">&lt;NONE&gt;</div>
            <div id="server">GITHUB: https://github.com/GEEKiDoS/polaris-touch</div>
        </div>
        <div class="fader">
            <div id="left">
                <div class="position visible"></div>
            </div>
            <div id="right">
                <div class="position visible"></div>
            </div>
        </div>
        <div class="lane">
            <div></div>
            <div></div>
            <div></div>
            <div></div>
            <div></div>
            <div></div>
            <div></div>
            <div></div>
            <div></div>
            <div></div>
            <div></div>
            <div></div>
        </div>
    </div>

</body>
</html>
